# v7: バックグラウンドタスクと通知バス

**コアの洞察: 結果を待たないエージェントだけが、複数のことを同時にできる。**

v6のタスクシステムはタスク追跡を解決した。しかしサブエージェントでもbashコマンドでも、実行中はメインエージェントが待たなければならない:

```sh
Main Thread           Background Thread        Notification Queue
    |                       |                        |
    +-- run_in_bg() ------> |                        |
    |   (returns task_id)   |                        |
    |                       +-- execute fn() ------> |
    |                       +-- on complete -------> queue.put(attachment)
    |                                                |
    +-- drain_notifications() <----------------------+
    +-- inject attachment format notification
```

```
メインエージェント: Task("コードベースを探索") -> 待機中... -> 結果を受信 -> 続行
                                                  ^
                                             この間何もできない
```

## 解法: バックグラウンド実行 + 通知

2つの変更:

1. **バックグラウンド実行**: サブエージェントとbashをバックグラウンドで実行、メインエージェントは作業を継続
2. **通知バス**: バックグラウンドタスクが完了したら、通知でメインエージェントに知らせる

```
メインエージェント:
  Task(background) ──┐
  Bash(background) ──┼── 他の作業を継続
  Task(background) ──┘
                          <- 通知: "タスクAが完了"
                          <- 通知: "コマンドBが完了"
```

## BackgroundTaskデータクラス

各バックグラウンドタスクは `BackgroundTask` インスタンスで追跡される。フィールドは以下の通り:

```python
@dataclass
class BackgroundTask:
    task_id: str               # 型プレフィックス付きの一意ID（例: "b3f7c2"）
    task_type: str             # "bash" または "agent"
    thread: threading.Thread   # 作業を実行するデーモンスレッド
    output: str                # キャプチャされた結果（完了時に格納）
    status: str                # "running" | "completed" | "error" | "stopped"
    event: threading.Event     # タスク完了時にシグナル、ブロッキング待機を可能にする
```

`event`フィールドは同期プリミティブ。`get_output(block=True)` は `event.wait()` を呼び出してバックグラウンドスレッドの完了シグナルまでスリープし、ビジーポーリングを回避する。

## バックグラウンドタスクの種類

各バックグラウンドタスクには異なるIDプレフィックスがあり、IDを見れば種類がわかる:

| 種類 | プレフィックス | 典型的な用途 |
|------|---------------|-------------|
| local_bash | `b` | テスト、lint、ビルドの実行 |
| local_agent | `a` | コード探索、ファイル分析 |
| in_process_teammate | `t` | Teammate協力 (v8) |

IDは `{プレフィックス}{uuid4_hex[:6]}` の形式で生成される（例: `b3a9f1` や `a7c2d4`）。プレフィックスにより、ログや通知での型の識別が即座にできる。

## スレッド実行モデル

バックグラウンドタスクはPythonのデーモンスレッド（`daemon=True`）で実行される。実行ラッパーは以下のパターンに従う:

```python
def wrapper():
    try:
        result = func()              # 実際の作業を実行
        bg_task.output = result
        bg_task.status = "completed"
    except Exception as e:
        bg_task.output = f"Error: {e}"
        bg_task.status = "error"      # エラーはキャプチャされ、伝播しない
    finally:
        output_path = self._write_output(task_id, bg_task.output)
        bg_task.event.set()           # 常に完了シグナルを発行
        # cli.js attachment pipelineの通知フォーマットに一致
        notifications.put({
            "type": "attachment",
            "attachment": {
                "type": "task_status",
                "task_id": task_id,
                "task_type": bg_task.task_type,
                "status": bg_task.status,
                "summary": bg_task.output[:500],
                "output_file": str(output_path),
            },
        })
```

主要な特性:
- **エラー隔離**: 例外はキャプチャされ `output` に格納。メインエージェントをクラッシュさせない
- **通知保証**: `finally` ブロックにより、タスクの成功/失敗を問わず必ず通知がプッシュされる
- **デーモンスレッド**: メインプロセスが終了すると、全バックグラウンドスレッドが自動終了

## バックグラウンド実行のトリガー

`run_in_background`パラメータをサポートするツールはすべてバックグラウンドで実行可能:

```python
# フォアグラウンド（ブロッキング）
Task(prompt="コードを分析")               # 完了まで待機

# バックグラウンド（ノンブロッキング）
Task(prompt="コードを分析", run_in_background=True)
# -> 即座に返却 {"task_id": "a3f7c2", "status": "running"}
```

バックグラウンド開始後すぐにタスクIDが返り、メインエージェントは作業を継続。

## 2つの新ツール

### TaskOutput: バックグラウンドタスクの結果を読み取る

```python
# ブロッキング: 完了まで待つ
TaskOutput(task_id="a3f7c2", block=True, timeout=30000)
# -> {"status": "completed", "output": "...分析結果..."}

# ノンブロッキング: 状態を確認
TaskOutput(task_id="a3f7c2", block=False)
# -> {"status": "running", "output": "...現在の出力..."}
```

`timeout`パラメータ（ミリ秒）で無限ブロッキングを防ぐ。タイムアウト内にタスクが完了しなければ、現在の状態と部分的な出力が返される。

### TaskStop: バックグラウンドタスクを終了する

```python
TaskStop(task_id="a3f7c2")
# -> {"task_id": "a3f7c2", "status": "stopped"}
```

`stop_task` はステータスを `"stopped"` に設定しイベントをシグナルする。これは協調的な停止であり、スレッドを強制終了しない。実行中の関数はステータス変更を確認できる。`subprocess.run` で起動済みのbashコマンドは、完了（または自身のタイムアウト）まで実行される。

## 通知のドレイン/インジェクトサイクル

通知バスは `queue.Queue` で実装されている。メインエージェントループは各API呼び出しの前に**ドレインとインジェクト**のサイクルを実行する。通知はcli.jsのattachmentフォーマットに一致:

```python
# 1. ドレイン: キューから保留中の全通知を取り出す
notifications = BG.drain_notifications()

# 2. インジェクト: attachmentオブジェクトとして最後のuserメッセージに追加
# 各通知は既にattachmentフォーマット:
# {"type": "attachment", "attachment": {"type": "task_status", ...}}
if notifications:
    if messages[-1]["role"] == "user":
        content = messages[-1]["content"]
        if isinstance(content, list):
            content.extend(notifications)
        else:
            messages[-1]["content"] = [{"type": "text", "text": content}] + notifications
    else:
        messages.append({"role": "user", "content": notifications})
```

モデルは通知を会話コンテキスト内の構造化ブロックとして認識し、`TaskOutput` で完全な出力を取得するかサマリーで作業を継続するかを判断する。

## 出力ファイルシステム

バックグラウンドタスクの出力はディスク `.task_outputs/{task_id}.output` に保存される:

```python
OUTPUT_DIR = WORKDIR / ".task_outputs"

def _write_output(self, task_id, content):
    # cli.js jSA=32000 デフォルト、TASK_MAX_OUTPUT_LENGTH環境変数で最大160000に設定可能
    max_output_chars = int(os.getenv("TASK_MAX_OUTPUT_LENGTH", "32000"))
    path = OUTPUT_DIR / f"{task_id}.output"
    truncated = content[:max_output_chars]
    with open(path, "a") as f:
        f.write(truncated)
    return path
```

2つの目的:
1. 大きな出力が通知を膨張させない（500文字のサマリーのみ注入）
2. 出力がディスクに永続化され、コンテキスト圧縮後も失われない

## 典型的なフロー

```
ユーザー: "src/ と tests/ のコード品質を分析して"

メインエージェント:
  1. Task(background, prompt="src/を分析")     -> task_id="a1c4e9"
  2. Task(background, prompt="tests/を分析")   -> task_id="a7b2d3"
  3. Bash(background, command="eslint src/")    -> task_id="b5e8f1"

  （3つのタスクが並列実行）

  4. TaskOutput("a1c4e9", block=True)  -> 待機して結果を取得
  5. attachment通知: b5e8f1 completed   (ESLintが待機中に完了)
  6. TaskOutput("a7b2d3", block=True)  -> 2つ目の結果を取得
  7. 3つの結果を総合してレポートを作成
```

## Tasks (v6) との関係

2つのシステムは相互補完:

| | Tasks (v6) | バックグラウンドタスク (v7) |
|-|-----------|---------------------------|
| 目的 | 計画と追跡 | 並列実行 |
| 粒度 | 高レベルの目標 | 具体的な実行 |
| ライフサイクル | セッション横断で永続 | 単一セッション |
| 可視性 | タスクボード | 通知ストリーム |

Tasksは**何をするか**を管理し、バックグラウンドタスクは**どう並列にするか**を管理する。

## より深い洞察

> **直列から並列へ。**

v6のTasksはカンバンボード。何をすべきかを記録する。v7のバックグラウンドタスクはパイプライン。複数のラインが同時に動く。

通知バスが重要な接着層: メインエージェントはポーリング不要、タスク完了時にプッシュされる。「待機-実行-待機」の直列パターンが「発行-作業継続-通知受信」の並列パターンに変わる。

バックグラウンドタスクはv8のTeammateの基盤でもある: Teammateは本質的に特殊なバックグラウンドタスク（`t`プレフィックス）であり、同じ通知と出力のインフラを再利用する。

---

**直列の待機は時間の浪費、並列の通知が効率を解放する。**

[← v6](./v6-タスクシステム.md) | [READMEに戻る](../README_ja.md) | [v8 →](./v8-チーム通信.md)
