# v6: タスクシステム

**コアの洞察: 個人の付箋からチームのカンバンボードへ。**

v2で導入したTodoWriteは「モデルが計画を忘れる」問題を解決した。しかし圧縮（v5）とサブエージェント（v3）が加わると、TodoWriteの限界が露呈する。

## 問題

```
TodoWriteの問題:
  1. 書き込みは上書きモードのみ（毎回完全なリストを送信）
  2. 永続化なし（圧縮後にtodoが消える）
  3. オーナーなし（誰がこのタスクをやっている？）
  4. 依存関係なし（AはBの前に完了しなければならない）
  5. 並行安全でない（2つのエージェントが同時に書く = データ消失）
```

v5の圧縮はメモリ内のtodoを消去する。サブエージェント間でタスクを共有できない。タスクシステムはタスク管理を根本から再設計する。

## TodoWrite vs Tasks

| 特徴 | TodoWrite (v2) | Tasks (v6) |
|------|---------------|------------|
| 操作方式 | 上書き | CRUD（作成/読取/更新/削除） |
| 永続化 | メモリのみ（圧縮後消失） | ディスクファイル（圧縮後も生存） |
| 並行性 | 安全でない | ファイルロック |
| 依存関係 | なし | blocks / blockedBy |
| オーナー | なし | エージェント名 |
| マルチエージェント | 非対応 | ネイティブ対応 |

## データモデル

```python
@dataclass
class Task:
    id: str              # 自動採番ID（ハイウォーターマーク）
    subject: str         # 命令形タイトル: "Fix auth bug"
    description: str     # 詳細な説明
    status: str = "pending"  # pending | in_progress | completed
    active_form: str = ""    # 進行形: "Fixing auth bug"
    owner: str = ""          # 担当エージェント
    blocks: list = []        # このタスクがブロックしているタスク
    blocked_by: list = []    # このタスクをブロックしている前提タスク
    metadata: dict = {}      # 任意のキーバリューペア
```

各フィールドが必要な理由:

| フィールド | 理由 |
|-----------|------|
| `id` | CRUDに一意識別子が必要 |
| `owner` | マルチエージェント時に誰が担当かを識別 |
| `blocks/blockedBy` | タスク編成の依存グラフ |
| `description` | 別のエージェントでもタスクを理解できる |
| `metadata` | 拡張可能なキーバリューデータ |

## タスク状態マシン

```
+--------+     update(status)     +-------------+     update(status)     +-----------+
| pending| ------------------->   | in_progress | ------------------->   | completed |
+--------+                        +-------------+                        +-----------+
    ^                                    |
    |          update(status)            |
    +------------------------------------+
                  (再オープン)

  任意の状態 ---> deleted (ファイルはディスクから物理的に削除)
```

タスクが `completed` に遷移すると、依存するタスクの `blocked_by` リストが自動的に更新される。

## ハイウォーターマークID割り当て

タスクIDは既存のタスクファイルをスキャンするのではなく、ハイウォーターマークファイル（`.highwatermark`）を使って割り当てられる:

```python
HIGHWATERMARK_FILE = ".highwatermark"

def _next_id(self):
    """次のタスクIDを取得し、ハイウォーターマークを永続化"""
    with self._lock:
        self._highwatermark += 1
        (self.tasks_dir / HIGHWATERMARK_FILE).write_text(str(self._highwatermark))
        return str(self._highwatermark)
```

タスクが削除された場合のID再利用を防ぐ。起動時にファイルからハイウォーターマークを読み込み、ファイルが存在しない場合は既存タスクファイルのスキャンにフォールバック。

## ステータス変更時の自動オーナー割り当て

タスクが `in_progress` に遷移しオーナーがいない場合、エージェントが自動的に自分自身をオーナーに設定:

```python
if kwargs.get("status") == "in_progress" and not task.owner:
    task.owner = kwargs.get("owner", os.getenv("CLAUDE_AGENT_NAME", "agent"))
```

モデルがタスクを開始するたびに明示的に `owner` を設定する手間を省く。

## 4つのツール

```python
# TaskCreate: タスクを作成
task_create("Fix auth bug", description="...", active_form="Fixing auth bug")
# -> {"id": "1", "subject": "Fix auth bug"}

# TaskGet: 詳細を読取
task_get("1")
# -> {id, subject, description, status, blocks, blockedBy}

# TaskUpdate: ステータス、依存、オーナーを更新
task_update("1", status="in_progress")  # ownerを自動割り当て
task_update("2", addBlockedBy=["1"])    # 2は1に依存

# TaskList: 全タスクを一覧
task_list()
# -> [{id, subject, status, owner, blockedBy}, ...]
```

## 依存グラフ

```
TaskCreate: "Set up database"       -> #1
TaskCreate: "Write API endpoints"   -> #2
TaskCreate: "Write tests"           -> #3

TaskUpdate: id=2, addBlockedBy=["1"]     # APIはデータベースに依存
TaskUpdate: id=3, addBlockedBy=["1","2"] # テストは両方に依存
```

レンダリング結果:

```
#1. [>] Set up database          (in_progress)
#2. [ ] Write API endpoints      blocked by: #1
#3. [ ] Write tests              blocked by: #1, #2
```

#1が完了すると、#2のblockedByが自動でクリアされ、実行可能になる。

## 永続化

```python
def _task_path(self, task_id):
    return self.tasks_dir / f"{self._sanitize_id(task_id)}.json"

def save_task(task):
    """スレッドロックで並行安全を保証（本番環境ではファイルロック proper-lockfile を使用）"""
    path = self._task_path(task.id)
    path.write_text(json.dumps(asdict(task), indent=2))
```

タスクIDはサニタイズ（非英数字文字を `-` に置換）されファイル名として使用。例: ID `"1"` は `1.json` になる。

データベースではなくファイルを使う理由:
- タスクごとに1ファイル = きめ細かなロック
- サブエージェントが別プロセスにいる可能性がある
- JSONファイルは人間が読める、デバッグが容易
- タスクリストID解決順序: `CLAUDE_CODE_TASK_LIST_ID` 環境変数 > `CLAUDE_TEAM_NAME` 環境変数 > `"default"` にフォールバック

## 圧縮との連携 (v5)

タスクはディスクに永続化されるため、圧縮時に失われない:

```
圧縮前:  [100ターンの対話] + [5つのタスクがディスク上]
圧縮後:  [要約 + 最近5ターン] + [5つのタスクがディスク上]  <- タスクは完全に保持
```

TodoWriteにはこれができなかった。TodoWriteのタスクはメッセージ履歴の中にしかなく、圧縮後は消えてしまう。

## Feature Gate

教育コードでは、v6はTodoWriteを完全にTasksシステムに置き換える。2つのシステムは概念的に排他的:

```python
# v2はTodoWriteを使用（メモリ内、上書きのみ）
# v6はTaskCreate/Get/Update/Listを使用（ディスク永続化、CRUD操作）

# 実装では、v6は単にTasksツールを含み、TodoWriteを削除
ALL_TOOLS = BASE_TOOLS + [TASK_CREATE_TOOL, TASK_GET_TOOL,
                          TASK_UPDATE_TOOL, TASK_LIST_TOOL]
```

重要な違い: TodoWriteのデータはメッセージ履歴にのみ存在（圧縮で消失）、Tasksのデータはディスクに存在（圧縮後も保持）。

## より深い洞察

> **個人のメモからチームのカンバンボードへ。**

TodoWriteは付箋のようなもの。一人で使い、使い終わったら捨てる。Tasksはプロジェクトボードのようなもの。複数人で協力し、ステータスが遷移し、依存関係を追跡する。

これは**協調パラダイムの転換**:
- TodoWrite: モデルの自己規律ツール（v2の哲学: 制約が可能にする）
- Tasks: マルチエージェントの調整プロトコル（v6の哲学: 協調が可能にする）

エージェントが単体からグループになるとき、タスク管理は「チェックリスト」から「システム」へ進化しなければならない。

---

**チェックリストで1つのエージェントが整理され、タスクシステムでエージェント群が秩序を持つ。**

[← v5](./v5-コンテキスト圧縮.md) | [READMEに戻る](../README_ja.md) | [v7 →](./v7-バックグラウンドタスク.md)
