# v1: モデルがエージェント

**約200行。4ツール。すべてのコーディングエージェントの本質。**

Claude Codeの秘密？**秘密などない。**

CLIの装飾、プログレスバー、権限システムを取り除く。残るのは驚くほどシンプル：モデルがタスク完了までツールを呼び出すループ。

```
+------------------+     +------------------+
| System Prompt    | --> | API Call         |
| + 4 Tools        |     | (messages[])     |
+------------------+     +--------+---------+
    ^                              |
    |                     tool_use? --no--> Output
    |                              |yes
    +---- append result <-- [Execute Tool]
```

## コアの洞察

従来のアシスタント：
```
ユーザー -> モデル -> テキスト応答
```

エージェントシステム：
```
ユーザー -> モデル -> [ツール -> 結果]* -> 応答
                      ^___________|
```

アスタリスクが重要。モデルはタスク完了を決定するまでツールを**繰り返し**呼び出す。これがチャットボットを自律エージェントに変える。

**重要な洞察**: モデルが意思決定者。コードはツールを提供してループを実行するだけ。

## 4つの必須ツール

Claude Codeは約20のツールを持つ。しかし4つで90%のユースケースをカバー。

本番環境の名前マッピング: bash->Bash, read_file->Read, write_file->Write, edit_file->Edit。

| ツール | 目的 | 主な特徴 |
|--------|------|---------|
| `bash` | コマンド実行 | timeout=120秒、危険コマンドのブロック |
| `read_file` | 内容を読む | オプション行数制限、出力の切り詰め |
| `write_file` | 作成/上書き | 親ディレクトリの自動作成 |
| `edit_file` | 精密な変更 | 完全一致文字列の最初の出現箇所のみ置換 |

この4つのツールで、モデルは：
- コードベースを探索（`bash: find, grep, ls`）
- コードを理解（`read_file`）
- 変更を加える（`write_file`, `edit_file`）
- 何でも実行（`bash: python, npm, make`）

## エージェントループ

1つの関数で完全なエージェント：

```python
def agent_loop(messages):
    while True:
        # 1. モデルに聞く
        response = client.messages.create(
            model=MODEL, system=SYSTEM,
            messages=messages, tools=TOOLS
        )

        # 2. テキスト出力を表示
        for block in response.content:
            if hasattr(block, "text"):
                print(block.text)

        # 3. ツール呼び出しがなければ完了
        if response.stop_reason != "tool_use":
            return messages

        # 4. ツールを実行して続行
        results = []
        for tc in response.tool_calls:
            output = execute_tool(tc.name, tc.input)
            results.append({"type": "tool_result", "tool_use_id": tc.id, "content": output})

        messages.append({"role": "assistant", "content": response.content})
        messages.append({"role": "user", "content": results})
```

**なぜこれが機能するか：**
1. モデルがループを制御（`stop_reason != "tool_use"`までツールを呼び続ける）
2. 結果がコンテキストになる（"user"メッセージとしてフィードバック）
3. メモリは自動（messagesリストに履歴が蓄積）

## システムプロンプト

必要な唯一の「設定」：

```python
SYSTEM = f"""You are a coding agent at {WORKDIR}.

Loop: think briefly -> use tools -> report results.

Rules:
- Prefer tools over prose. Act, don't just explain.
- Never invent file paths. Use ls/find first if unsure.
- Make minimal changes. Don't over-engineer.
- After finishing, summarize what changed."""
```

複雑なロジックなし。明確な指示のみ。

## この設計が機能する理由

**1. シンプルさ**
ステートマシンなし。計画モジュールなし。フレームワークなし。

**2. モデルが考える**
モデルがどのツールを、どの順序で、いつ停止するか決定。

**3. 透明性**
すべてのツール呼び出しが可視。すべての結果が会話に。

**4. 拡張性**
ツール追加 = 1関数 + 1JSONスキーマ。

## 何が欠けているか

| 機能 | 省略理由 | 追加先 |
|------|----------|--------|
| Todo追跡 | 必須ではない | v2 |
| サブエージェント | 複雑さ | v3 |
| 権限 | 学習ではモデルを信頼 | 本番 |

要点：**コアは極小**。他のすべては改良。

## より大きな視点

Claude Code、Cursor Agent、Codex CLI、Devin—すべてこのパターンを共有：

```python
while not done:
    response = model(conversation, tools)
    results = execute(response.tool_calls)
    conversation.append(results)
```

違いはツール、表示、安全性。しかし本質は常に：**モデルにツールを与えて作業させる**。

---

**モデルがエージェント。これがすべての秘密。**

[← v0](./v0-Bashがすべて.md) | [READMEに戻る](../README_ja.md) | [v2 →](./v2-構造化プランニング.md)
