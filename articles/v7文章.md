# mini Claude Code v7：不等结果也能继续干活 -- 后台任务与通知 Bus

想象你是一个项目经理。你让三个人分别去做三件事：分析代码质量、跑测试套件、检查安全漏洞。合理的做法是什么？

**错误做法**：叫第一个人去，你站在旁边等他干完，再叫第二个人去，再等...

**正确做法**：三个人同时出发，你继续做自己的事，谁先干完谁先汇报。

v6 之前的 Agent 就是那个"站在旁边等"的项目经理。子代理执行时，主 Agent 完全阻塞，什么都做不了。

```sh
v6 及之前 (串行阻塞):

  主 Agent ----[派出子代理]----[等待...]----[等待...]----[收到结果]----[继续]
                                   ^
                              这段时间完全浪费

v7 (并行非阻塞):

  主 Agent ----[派出 A]----[派出 B]----[派出 C]----[继续其他工作]----
                  |            |            |                    |
               子代理 A     子代理 B     子代理 C              收到通知
                  |            |            |
               [独立执行]   [独立执行]   [独立执行]
```

v7 引入了两个核心机制：**后台执行**和**通知 Bus**。加起来不到 80 行新增代码，但把 Agent 从串行模式解放到了并行模式。

## 1. 后台任务的数据模型

```python
@dataclass
class BackgroundTask:
    task_id: str                    # 唯一标识, 带类型前缀
    task_type: str                  # "bash" 或 "agent"
    thread: threading.Thread        # 执行线程
    output: str = ""                # 执行结果
    status: str = "running"         # running | completed | error | stopped
    event: threading.Event          # 完成信号
```

每种后台任务有不同的 ID 前缀，一看 ID 就知道类型：

```sh
ID 前缀约定:
  b = bash 命令      (b3f7c2)   跑测试, lint, 构建
  a = 本地子代理      (a1c4e9)   探索代码, 分析文件
  t = Teammate       (t8d2a1)   v8 引入的持久协作者
```

## 2. BackgroundManager：核心 80 行

```python
class BackgroundManager:
    def __init__(self):
        self._tasks: dict[str, BackgroundTask] = {}
        self._notifications: Queue = Queue()
        self._lock = threading.Lock()

    def run_in_background(self, func, task_type: str = "a") -> str:
        prefix = "b" if task_type == "bash" else "a"
        task_id = f"{prefix}{uuid.uuid4().hex[:6]}"

        bg_task = BackgroundTask(task_id=task_id, task_type=task_type)

        def wrapper():
            try:
                result = func()
                bg_task.output = result
                bg_task.status = "completed"
            except Exception as e:
                bg_task.output = f"Error: {e}"
                bg_task.status = "error"
            finally:
                bg_task.event.set()
                # 完成后推送通知
                self._notifications.put({
                    "task_id": task_id,
                    "status": bg_task.status,
                    "summary": bg_task.output[:500],
                })

        thread = threading.Thread(target=wrapper, daemon=True)
        bg_task.thread = thread

        with self._lock:
            self._tasks[task_id] = bg_task

        thread.start()
        return task_id
```

`run_in_background` 的设计很简洁：把任何函数扔进线程，立即返回 task_id。函数执行完后，往通知队列里推一条消息。

关键设计：`daemon=True` 让后台线程不阻塞程序退出；`threading.Event` 提供等待/唤醒语义。

## 3. 触发后台执行

任何支持 `run_in_background` 参数的工具都可以后台运行：

```python
def run_bash(cmd: str, background: bool = False) -> str:
    if background:
        task_id = BG.run_in_background(lambda: _exec_bash(cmd), task_type="bash")
        return json.dumps({"task_id": task_id, "status": "running"})
    return _exec_bash(cmd)


def run_subagent(description, prompt, agent_type, background=False):
    if background:
        task_id = BG.run_in_background(
            lambda: _exec_subagent(description, prompt, agent_type),
            task_type="agent"
        )
        return json.dumps({"task_id": task_id, "status": "running"})
    return _exec_subagent(description, prompt, agent_type)
```

同一个函数，一个参数切换前台/后台。前台模式阻塞等待结果，后台模式立即返回 task_id。

## 4. 两个新工具：TaskOutput 和 TaskStop

后台任务启动后，Agent 需要能查看结果和停止任务：

```python
# TaskOutput: 获取后台任务结果
def get_output(self, task_id: str, block: bool = True, timeout: int = 30000):
    bg_task = self._tasks.get(task_id)
    if not bg_task:
        return {"error": f"Task {task_id} not found"}

    # block=True: 等待完成; block=False: 立即返回当前状态
    if block and bg_task.status == "running":
        bg_task.event.wait(timeout=timeout / 1000)

    return {
        "task_id": task_id,
        "status": bg_task.status,
        "output": bg_task.output,
    }

# TaskStop: 终止后台任务
def stop_task(self, task_id: str):
    bg_task = self._tasks.get(task_id)
    if bg_task and bg_task.status == "running":
        bg_task.status = "stopped"
        bg_task.event.set()
    return {"task_id": task_id, "status": "stopped"}
```

`TaskOutput` 的 `block` 参数提供了两种使用模式：

```sh
模式 1: 主动等待 (block=True)
  Agent: "我现在需要这个结果, 等它完成"
  TaskOutput(task_id="a3f7c2", block=True, timeout=30000)

模式 2: 异步轮询 (block=False)
  Agent: "看看完成没, 没完成我继续干别的"
  TaskOutput(task_id="a3f7c2", block=False)
  -> {"status": "running"} -> 继续其他工作
```

## 5. 通知 Bus：被动接收的关键

通知 Bus 是 v7 最精妙的设计。上面两个工具是 Agent 主动查询，通知 Bus 是系统主动推送。

```python
def drain_notifications(self) -> list:
    """排空所有待处理的通知"""
    notifications = []
    while not self._notifications.empty():
        try:
            notifications.append(self._notifications.get_nowait())
        except Exception:
            break
    return notifications
```

通知在 Agent Loop 的每一轮开始时注入：

```python
def agent_loop(messages: list) -> list:
    while True:
        messages = CTX.microcompact(messages)

        # 排空通知队列, 注入到对话中
        notifications = BG.drain_notifications()
        if notifications:
            notif_parts = []
            for n in notifications:
                notif_parts.append(
                    f"Background task {n['task_id']} {n['status']}.\n"
                    f"Summary: {n['summary']}"
                )
            notif_text = "\n\n".join(notif_parts)
            # 以附件形式追加到最后一条 user message
            if messages and messages[-1].get("role") == "user":
                content = messages[-1].get("content", "")
                if isinstance(content, str):
                    messages[-1]["content"] = content + "\n\n" + notif_text
                elif isinstance(content, list):
                    content.append({"type": "text", "text": notif_text})
            else:
                messages.append({"role": "user", "content": notif_text})

        response = client.messages.create(...)
```

通知的注入方式很讲究：**追加到现有的 user message 中**，而不是创建新消息。这避免了消息交替约束的问题（Anthropic API 要求 user/assistant 严格交替）。

## 6. 通知 Bus 的哲学：推送 vs 轮询

通知 Bus 选择了**推送模式**而非轮询模式：

```sh
轮询模式 (低效):                    推送模式 (高效):
  Agent: "完成了吗?" -> 没有          Agent: (继续干别的事)
  Agent: "完成了吗?" -> 没有          系统: (完成了, 推通知到队列)
  Agent: "完成了吗?" -> 完成了!        Agent: (下一轮自动看到, 零成本)
  (浪费了多轮 API 调用)
```

推送模式不消耗额外的 API 调用。通知以纯文本形式附加到消息中，让模型能直接读取。

v6 的 Tasks 和 v7 的后台任务是两个正交的维度：Tasks 是战略层（做什么），后台任务是战术层（怎么并行做）。

## 7. 为 v8 Teammate 奠基

注意 BackgroundManager 的 ID 前缀中，`t` 已经预留给 Teammate：

```python
prefix = {"bash": "b", "agent": "a", "teammate": "t"}.get(task_type, "a")
```

Teammate 本质上是一种"永不结束的后台任务"，通过通知 Bus 与主 Agent 通信。v7 的基础设施是 v8 的底层依赖。

## 8. 更深的洞察：从同步到异步

v7 代表了 Agent 架构中一个根本性的范式转变。这和软件工程中从同步到异步编程的演进完全对应：Node.js 的事件循环、Go 的 goroutine、Python 的 asyncio——核心思想都一样：**不要等结果，发出请求后继续做别的事，结果来了再处理。**

通知 Bus 就是 Agent 世界的事件循环。

---

**串行等待浪费时间，并行通知解放效率。通知 Bus 是让 Agent 从"一次做一件事"到"同时做多件事"的关键胶水层。**

完整代码见仓库 `v7_background_agent.py`。
