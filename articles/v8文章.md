# mini Claude Code v8：Agent 团队通信 -- 从命令到协作

v3 引入了子代理，v7 引入了后台执行。它们解决了"做什么"和"怎么并行做"的问题。但还缺一个关键能力：**持久化的团队协作**。

子代理是一次性的——执行完就销毁，上下文消失。当任务是"前端和后端同时开发一个新功能"时，一次性子代理不够用：前端做完了，后端想问"API 接口定义是什么"，但前端已经"死了"。

v8 引入 Teammate 机制：持久的 Agent 同事，通过消息邮箱通信，共享任务看板。

v8 的实现按职责拆分为三个文件：
- `v8a_team_foundation.py` -- 团队基础设施：Teammate 数据模型、TeammateManager、spawn/loop 逻辑、config 持久化
- `v8b_messaging.py` -- 消息系统：SendMessage、inbox 路由、_write_to_inbox、MESSAGE_TYPES
- `v8c_coordination.py` -- 协调协议：shutdown 协议、plan_approval、共享任务看板集成

## 1. 三种角色

```sh
Subagent (实习生):
  "去把这个文件分析一下, 回来告诉我结果"
  -> 干一件事, 回来汇报, 离开

Teammate (同事):
  "你负责后端开发, 有问题随时沟通"
  -> 在分配的任务上工作, 互相沟通

Team Lead (经理):
  "我来拆任务, 你们各自负责, 有进展告诉我"
  -> 创建团队, 分配工作, 协调
```

| 特性 | Subagent (v3) | Teammate (v8) |
|------|---------------|---------------|
| 生命周期 | 执行一次就销毁 | 持久运行 |
| 通信方式 | 返回值（单向） | 消息协议（双向, 5 种类型） |
| 并行方式 | 伪并行（主 Agent 等待） | 真并行（独立线程） |
| 任务管理 | 无 | 共享 Tasks 看板 (v6) |

## 2. 系统架构：五层设计

v8 的团队系统由五个层次组成，从上到下依次是：

```sh
+---------------------------------------------------------------+
|  Layer 5: Team Lead (主 Agent, 拥有 ALL_TOOLS)                  |
|  TeamCreate / SendMessage / TeamDelete / Task(team_name=...)    |
+---------------------------------------------------------------+
          |                   |                    |
+---------------------------------------------------------------+
|  Layer 4: Teammate Threads (守护线程, 拥有 TEAMMATE_TOOLS)       |
|  独立 Agent Loop + 独立上下文 + 独立压缩                          |
+---------------------------------------------------------------+
          |                   |                    |
+---------------------------------------------------------------+
|  Layer 3: Message Protocol (消息协议)                            |
|  message / broadcast / shutdown_request/response / plan_approval|
+---------------------------------------------------------------+
          |                   |                    |
+---------------------------------------------------------------+
|  Layer 2: Inbox Files (JSONL 文件邮箱)                           |
|  .teams/{team}/{name}_inbox.jsonl + .lock 原子写入                |
+---------------------------------------------------------------+
          |                   |                    |
+---------------------------------------------------------------+
|  Layer 1: Shared State (共享状态)                                |
|  .tasks/ (任务看板) + .teams/config.json (团队元数据)              |
+---------------------------------------------------------------+
```

每层有明确职责：Layer 1 提供持久化状态，Layer 2 提供通信管道，Layer 3 定义协议语义，Layer 4 运行独立 Agent，Layer 5 负责编排。

## 3. 收件箱路由架构

消息从发送方到接收方的完整路由路径：

```sh
SendMessage(recipient="backend", content="API schema ready")
    |
    v
TeammateManager.send_message()
    |
    +-- msg_type == "broadcast"?
    |     yes --> 遍历团队所有成员（排除 sender）
    |             for tm in team.values():
    |                 _write_to_inbox(tm.inbox_path, message)
    |
    +-- msg_type == "message"?
          yes --> _find_teammate(recipient, team_name)
                  _write_to_inbox(teammate.inbox_path, message)
                      |
                      v
                  +---------------------------+
                  | 获取锁文件 (.lock)           |
                  | os.O_CREAT | os.O_EXCL     |
                  | 最多重试 50 次, 每次 50ms    |
                  +---------------------------+
                      |
                      v
                  +---------------------------+
                  | 追加写入 JSONL              |
                  | inbox.jsonl <<             |
                  | {"type":"message",...}\n   |
                  +---------------------------+
                      |
                      v
                  +---------------------------+
                  | 释放锁文件                   |
                  | lock_path.unlink()          |
                  +---------------------------+
```

## 4. 收件箱锁机制

v8 使用文件锁而非 `fcntl.flock`。锁机制基于 `os.O_CREAT | os.O_EXCL` 实现原子性：

```python
# v8b_messaging.py: TeammateManager._write_to_inbox()
def _write_to_inbox(self, inbox_path: Path, message: dict):
    lock_path = inbox_path.with_suffix(".lock")
    # 自旋锁：尝试创建排他锁文件
    for _ in range(50):                              # 最多 50 次
        try:
            fd = os.open(str(lock_path),
                         os.O_CREAT | os.O_EXCL | os.O_WRONLY)  # 原子创建
            os.close(fd)                              # 创建成功 = 获得锁
            break
        except FileExistsError:                       # 锁已被持有
            time.sleep(0.05)                          # 等 50ms 后重试
    else:
        pass  # 超时后回退：无锁写入（不阻塞流程）

    try:
        with open(inbox_path, "a") as f:              # 追加写入
            f.write(json.dumps(message) + "\n")
    finally:
        try:
            lock_path.unlink(missing_ok=True)         # 释放锁
        except OSError:
            pass
```

为什么用文件锁而不是 `threading.Lock`：
- 文件锁天然跨进程，为将来进程级隔离留余地
- 锁文件可以人工查看和清理（`.lock` 文件残留即可 `rm`）
- 超时后回退到无锁写入，避免死锁阻塞整个系统

## 5. config.json 持久化设计

每次团队成员变化时，`config.json` 被更新以反映当前状态：

```python
# v8a_team_foundation.py: TeammateManager._update_team_config()
def _update_team_config(self, team_name: str):
    team_dir = TEAMS_DIR / team_name
    config_path = team_dir / "config.json"
    config = {}
    if config_path.exists():
        try:
            config = json.loads(config_path.read_text())
        except json.JSONDecodeError:
            pass  # 文件损坏时静默恢复
    config["members"] = [
        {"name": tm.name, "agent_id": tm.agent_id, "status": tm.status}
        for tm in self._teams.get(team_name, {}).values()
    ]
    config_path.write_text(json.dumps(config, indent=2))
```

`config.json` 的恢复策略：即使文件损坏（JSON 解析失败），代码会静默创建新的空配置而不是崩溃。这是防御性设计——团队的运行时状态以内存中的 `_teams` 字典为准，`config.json` 只是持久化副本。

调用时机：
- `spawn_teammate()` 后：新成员加入
- `_teammate_loop()` 退出时：成员状态变为 shutdown
- `delete_team()` 后：团队被删除

## 6. 工具权限分层：ALL_TOOLS vs TEAMMATE_TOOLS

Teammate 和 Team Lead 的工具集差异是有意设计的层级控制：

```python
# v8a_team_foundation.py
# Teammate 工具集：基础工具 + 任务 CRUD（含 TaskGet）+ 消息
TEAMMATE_TOOLS = BASE_TOOLS + [
    TASK_CREATE_TOOL, TASK_GET_TOOL,
    TASK_UPDATE_TOOL, TASK_LIST_TOOL,
    SEND_MESSAGE_TOOL
]

# Team Lead 工具集：一切
ALL_TOOLS = BASE_TOOLS + [
    SUBAGENT_TOOL, SKILL_TOOL,
    TASK_CREATE_TOOL, TASK_GET_TOOL, TASK_UPDATE_TOOL, TASK_LIST_TOOL,
    TASK_OUTPUT_TOOL, TASK_STOP_TOOL,
    TEAM_CREATE_TOOL, SEND_MESSAGE_TOOL, TEAM_DELETE_TOOL,
]
```

对比表：

| 工具 | Team Lead | Teammate | 限制理由 |
|------|-----------|----------|----------|
| bash, read_file, write_file, edit_file | 有 | 有 | 基础能力 |
| TaskCreate, TaskGet, TaskUpdate, TaskList | 有 | 有 | 协作必需 |
| SendMessage | 有 | 有 | 通信必需 |
| Task（生成子代理/Teammate） | 有 | **无** | 防止无限生成 |
| Skill | 有 | **无** | 减少上下文膨胀 |
| TaskOutput, TaskStop | 有 | **无** | 后台任务由 Lead 管控 |
| TeamCreate, TeamDelete | 有 | **无** | 团队生命周期由 Lead 管控 |

核心原则：Teammate 是工人，不是管理者。它们能做具体工作、汇报进度、互相沟通，但不能生成新的代理或管理团队结构。

## 7. _teammate_loop 详细走读

v8 的 `_teammate_loop` 是 Teammate 的核心执行逻辑。逐段分析：

```python
# v8a_team_foundation.py
def _teammate_loop(self, teammate: Teammate, initial_prompt: str):
    # 1. 设置终端输出前缀，带 ANSI 颜色
    color = teammate.color
    reset = COLOR_RESET
    prefix = f"{color}[{teammate.agent_id}]{reset}"

    # 2. 构建 Teammate 专属的 system prompt
    #    包含：名字、agent_id、team_name、工作目录
    sub_system = f"""You are teammate '{teammate.name}' ({teammate.agent_id}) \
in team '{teammate.team_name}' at {WORKDIR}.
Work on your assigned tasks. Use TaskList to find tasks.
Use TaskGet to read task details before starting work.
Use TaskUpdate to mark progress. Use SendMessage to communicate with teammates.
Complete work efficiently and report results clearly."""

    # 3. 使用 TEAMMATE_TOOLS（不含 Task/Skill/TeamCreate 等）
    sub_tools = _get_teammate_tools()

    # 4. 初始消息：用户提供的 prompt
    sub_messages = [{"role": "user", "content": initial_prompt}]

    # 5. 主循环
    while teammate.status != "shutdown":
        teammate.status = "active"

        try:
            # 5a. 每轮开始前检查收件箱
            inbox_messages = self.check_inbox(teammate.name, teammate.team_name)
            if inbox_messages:
                # 将消息格式化为 XML 并注入对话
                inbox_text = "\n".join(
                    f'<teammate-message sender="{m.get("sender", "?")}" '
                    f'type="{m.get("type", "message")}">\n'
                    f'{m.get("content", "")}\n</teammate-message>'
                    for m in inbox_messages
                )
                # 追加到最后一条 user 消息，或创建新消息
                # ...（处理 str 和 list 两种 content 格式）

            # 5b. 执行压缩
            sub_messages = CTX.microcompact(sub_messages)
            if CTX.should_compact(sub_messages):
                sub_messages = CTX.auto_compact(sub_messages)

            # 5c. API 调用
            response = client.messages.create(
                model=MODEL, system=sub_system,
                messages=sub_messages, tools=sub_tools, max_tokens=8000,
            )

            # 5d. 有工具调用 -> 执行并继续循环
            if response.stop_reason == "tool_use":
                tool_calls = [b for b in response.content if b.type == "tool_use"]
                results = []
                for tc in tool_calls:
                    output = execute_tool(tc.name, tc.input)
                    output = CTX.handle_large_output(output)
                    results.append({"type": "tool_result",
                                    "tool_use_id": tc.id, "content": output})
                sub_messages.append({"role": "assistant", "content": response.content})
                sub_messages.append({"role": "user", "content": results})
                continue

            # 5e. 无工具调用 -> 工作完成，关闭
            else:
                teammate.status = "shutdown"
                self._update_team_config(teammate.team_name)
                return

        except Exception as e:
            # 5f. 异常 -> 静默关闭，不影响其他线程
            teammate.status = "shutdown"
            self._update_team_config(teammate.team_name)
            return
```

v8 与 v9 在 `_teammate_loop` 中的关键区别：v8 在 `stop_reason != "tool_use"` 时直接关闭（5e），v9 则进入 idle 阶段继续等待新工作。

## 8. agent_id 格式与 ANSI 颜色循环

每个 Teammate 在创建时获得两个标识属性：

```python
# v8a_team_foundation.py: Teammate.__post_init__()
def __post_init__(self):
    if not self.agent_id:
        self.agent_id = f"{self.name}@{self.team_name}"
        # 例如: "backend@rest-to-graphql"

# v8a_team_foundation.py: TeammateManager.spawn_teammate()
color_idx = len(self._teams[team_name]) % len(TEAMMATE_COLORS)
# 第 0 个成员 -> cyan, 第 1 个 -> yellow, 第 2 个 -> magenta, ...
```

`agent_id` 的格式是 `{name}@{team_name}`（如 `frontend@my-project`），终端输出时用 ANSI 颜色前缀标识：

```sh
# 终端输出效果（颜色在此用文字表示）：
[cyan]    [frontend@my-project]  执行 bash: npm install
[yellow]  [backend@my-project]   执行 read_file: src/api.py
[magenta] [analyst@my-project]   执行 bash: grep -r "TODO"
```

5 种颜色循环（cyan -> yellow -> magenta -> green -> blue），超过 5 个成员时从头循环。颜色分配基于成员在团队中的加入顺序（`len(self._teams[team_name]) % 5`）。

## 9. 三种代理机制对比

| 维度 | v3 Subagent | v7 Background | v8 Teammate |
|------|------------|----------------|-------------|
| 生命周期 | 一次性（同步阻塞） | 一次性（异步后台） | 持久（独立线程） |
| 上下文 | 完全隔离 | 完全隔离 | 完全隔离 + 独立压缩 |
| 通信 | 返回值 | 通知 Bus | 消息邮箱（5 种类型） |
| 任务感知 | 无 | 无 | 共享 Tasks 看板 |
| 工具集 | 按类型过滤 | 按类型过滤 | TEAMMATE_TOOLS |
| 结果获取 | 同步返回 | TaskOutput | SendMessage |
| 适用场景 | 单次探索/编码 | 多任务并行 | 持续协作 |
| ID 格式 | 无 | `{b/a}{hex6}` | `{name}@{team}` |
| 主 Agent | 阻塞等待 | 继续工作 | 继续工作 |

核心区别：Subagent 是函数调用（调用-返回），Background 是异步任务（发起-通知），Teammate 是独立 Agent（生成-通信-关闭）。

## 10. 五种消息类型

```python
MESSAGE_TYPES = {
    "message",                  # 点对点消息
    "broadcast",                # 广播给所有人
    "shutdown_request",         # 请求关闭
    "shutdown_response",        # 确认关闭
    "plan_approval_response",   # Team Lead 审批计划
}
```

消息通过文件邮箱传递（`.teams/<team>/<name>_inbox.jsonl`），用文件而不是内存队列，原因和 Tasks 一样：跨线程安全，人类可调试。

## 11. 团队管理流程

```python
# 1. 创建团队
TeamCreate(name="rest-to-graphql")

# 2. 生成 Teammate（通过 Task 工具，指定 team_name + name）
Task(name="backend", team_name="rest-to-graphql", prompt="处理后端迁移")
Task(name="frontend", team_name="rest-to-graphql", prompt="处理前端更新")

# 3. 与 Teammate 通信
SendMessage(recipient="backend", content="Database schema is ready")

# 4. 解散团队
TeamDelete(name="rest-to-graphql")
```

同一个 `Task` 工具，三种模式：
- 无额外参数：同步子代理 (v3)
- `run_in_background=True`：后台子代理 (v7)
- `team_name + name`：持久 Teammate (v8)

## 12. 洞察

v8 建立了团队通信的基础设施：
- **团队生命周期**：创建、成员管理、解散
- **消息邮箱**：JSONL 文件，读取即清空
- **工具分层**：Lead 有全部工具，Teammate 有工作子集
- **锁机制**：文件锁保证并发写入安全

但 v8 的 Teammate 仍然是"被动同事"——被分配工作，执行，完成。它们不会自己去找活干。

下一步 v9 将赋予 Teammate 自治能力：空闲循环、自动认领任务、压缩后身份保持。

---

**从一个人下命令，到一群人互相协作。v8 建立了沟通的桥梁。**

完整代码见仓库 `v8a_team_foundation.py`、`v8b_messaging.py`、`v8c_coordination.py`。
